/*
 * Copyright 2017-2018 The MCUSim Project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the MCUSim or its parts nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include <stdint.h>
#include <time.h>
#include "mcusim/mcusim.h"
#include "mcusim/tsq.h"

#define TERA			1000000000000.0
#define MAX_CLK_PRINTS		50
#define LOG			(mcu.log)
#define LOGSZ			MSIM_AVR_LOGSZ

static void print_reg16(char *buf, uint32_t len, uint8_t hr, uint8_t lr);
static void print_reg(char *buf, unsigned int len, unsigned char r);
static void print_regbit(char *buf, unsigned int len, unsigned char r,
                         short bit);

FILE *MSIM_AVR_VCDOpenDump(struct MSIM_AVR *mcu, const char *dumpname)
{
	FILE *f;
	time_t timer;
	struct tm *tm_info;
	uint32_t regs = MSIM_AVR_VCD_REGS;
	struct MSIM_AVR_VCDReg *reg;
	uint8_t rh, rl;
	uint32_t reg_val;
	char buf[32];
	int rc;

	f = fopen(dumpname, "w");
	if (f == NULL) {
		return NULL;
	}

	time(&timer);
	tm_info = localtime(&timer);
	strftime(buf, sizeof buf, "%Y-%m-%dT%H:%M:%S%z", tm_info);

	/* Printing VCD header */
	fprintf(f, "$date\n\t%s\n$end\n", buf);
	fprintf(f, "$version\n\tGenerated by MCUSim %s\n$end\n", MSIM_VERSION);
	fprintf(f, "$comment\n\tDump of a simulated %s\n$end\n", mcu->name);
	fprintf(f, "$timescale\n\t%lu ps\n$end\n",
	        (unsigned long)(((1.0/(double)mcu->freq)*TERA)/2.0));
	fprintf(f, "$scope\n\tmodule %s\n$end\n", mcu->name);

	/* Declare VCD variables to dump */
	fprintf(f, "$var reg 1 CLK_IO CLK_IO $end\n");
	for (uint32_t i = 0; i < regs; i++) {
		if (mcu->vcd[i].i < 0) {
			break;
		}
		reg = &mcu->vcd[i];

		/* Are we going to dump a register bit only? */
		if (mcu->vcd[i].reg_lowi >= 0) {
			fprintf(f, "$var reg 16 %s %s $end\n",
			        mcu->vcd[i].name,
			        mcu->vcd[i].name);
		} else if (mcu->vcd[i].n < 0) {
			fprintf(f, "$var reg 8 %s %s $end\n",
			        reg->name, reg->name);
		} else {
			fprintf(f, "$var reg 1 %s%d %s%d $end\n",
			        reg->name, mcu->vcd[i].n,
			        reg->name, mcu->vcd[i].n);
		}
	}
	fprintf(f, "$upscope $end\n");
	fprintf(f, "$enddefinitions $end\n");

	/* Dumping initial register values to VCD file */
	fprintf(f, "$dumpvars\n");
	fprintf(f, "b0 CLK_IO\n");
	for (uint32_t i = 0; i < regs; i++) {
		if (mcu->vcd[i].i < 0) {
			break;
		}

		reg = &mcu->vcd[i];
		reg_val = *mcu->ioregs[reg->i].addr;
		if (mcu->vcd[i].reg_lowi >= 0) {
			rh = *mcu->ioregs[reg->i].addr;
			rl = *mcu->ioregs[reg->reg_lowi].addr;
			reg_val = ((uint16_t)(rh<<8)&0xFF00U)|
			          (uint16_t)(rl&0x00FFU);
		}

		if (mcu->vcd[i].reg_lowi >= 0) {
			print_reg16(buf, sizeof buf, rh, rl);
			fprintf(f, "b%s %s\n", buf, mcu->vcd[i].name);
		} else if (mcu->vcd[i].n < 0) {
			print_reg(buf, sizeof buf, *mcu->ioregs[reg->i].addr);
			fprintf(f, "b%s %s\n", buf, reg->name);
		} else {
			print_regbit(buf, sizeof buf,
			             *mcu->ioregs[reg->i].addr, mcu->vcd[i].n);
			fprintf(f, "b%s %s%d\n", buf, reg->name,
			        mcu->vcd[i].n);
		}
	}
	fprintf(f, "$end\n");

	/* Initialize queue to keep VCD dump frames. */
	rc = MSIM_TSQ_Init(&mcu->vcd_queue);
	if (rc != MSIM_TSQ_OK) {
		fclose(f);
		f = NULL;
		MSIM_LOG_ERROR("failed to initialize a queue for VCD dump "
		               "frames");
	}

	return f;
}

void MSIM_AVR_VCDDumpFrame(FILE *f, struct MSIM_AVR *mcu, uint64_t tick,
                           uint8_t fall)
{
	static uint32_t clk_prints_left = 0;
	uint32_t regs = MSIM_AVR_VCD_REGS;
	uint8_t print_tick = 1;
	uint8_t new_value = 0;
	uint8_t rh, rl;
	uint32_t reg_val;
	struct MSIM_AVR_VCDReg *reg;
	char buf[32];

	/* Do we have at least one register which value has changed? */
	for (uint32_t i = 0; i < regs; i++) {
		int8_t n; /* Bit index of a register */

		/* There should be no register changes on fall */
		if (fall == 1U) {
			break;
		}
		/* Only requested registers to be dumped only */
		if (mcu->vcd[i].i < 0) {
			break;
		}

		reg = &mcu->vcd[i];
		reg_val = *mcu->ioregs[reg->i].addr;
		if (mcu->vcd[i].reg_lowi >= 0) {
			rh = *mcu->ioregs[reg->i].addr;
			rl = *mcu->ioregs[reg->reg_lowi].addr;
			reg_val = ((uint16_t)(rh<<8)&0xFF00U)|
			          (uint16_t)(rl&0x00FFU);
		}

		/* Has register value been changed? */
		n = mcu->vcd[i].n;
		if ((n < 0) && (reg_val != reg->old_val)) {
			new_value = 1;
			break;
		}
		if (n >= 0 && (((reg_val >> n)&1)!=((reg->old_val >> n)&1))) {
			new_value = 1;
			break;
		}
	}

	/* There is no register which value changed. Should we print a
	 * clock pulse in this case? */
	if (new_value == 0) {
		if (!clk_prints_left) {
			return;
		}
		fprintf(f, "#%lu\n", tick);
		fprintf(f, "b%d CLK_IO\n", !fall ? 1 : 0);
		if (fall) {
			clk_prints_left--;
		}
		return;
	}

	/* We've at least one register which value changed. Let's print it. */
	for (uint32_t i = 0; i < regs; i++) {
		/* Only requested registers to be dumped only */
		if (mcu->vcd[i].i < 0) {
			break;
		}

		reg = &mcu->vcd[i];
		reg_val = *mcu->ioregs[reg->i].addr;
		if (mcu->vcd[i].reg_lowi >= 0) {
			rh = *mcu->ioregs[reg->i].addr;
			rl = *mcu->ioregs[reg->reg_lowi].addr;
			reg_val = ((uint16_t)(rh<<8)&0xFF00U)|
			          (uint16_t)(rl&0x00FFU);
		}
		/* Has it been changed? */
		if (reg_val == reg->old_val) {
			continue;
		}

		/* Print current tick and a main clock only once. */
		if (print_tick) {
			print_tick = 0;
			fprintf(f, "#%lu\n", tick);
			fprintf(f, "b1 CLK_IO\n");
			clk_prints_left = MAX_CLK_PRINTS;
		}

		/* Print selected register */
		if (mcu->vcd[i].reg_lowi >= 0) {
			print_reg16(buf, sizeof buf, rh, rl);
			fprintf(f, "b%s %s\n", buf, mcu->vcd[i].name);
		} else if (mcu->vcd[i].n < 0) {
			print_reg(buf, sizeof buf, *mcu->ioregs[reg->i].addr);
			fprintf(f, "b%s %s\n", buf, reg->name);
		} else {
			print_regbit(buf, sizeof buf,
			             *mcu->ioregs[reg->i].addr, mcu->vcd[i].n);
			fprintf(f, "b%s %s%d\n", buf, reg->name,
			        mcu->vcd[i].n);
		}
	}

	/* Update previous values of the registers */
	for (uint32_t i = 0; i < regs; i++) {
		/* Only requested registers to be dumped only */
		if (mcu->vcd[i].i < 0) {
			break;
		}

		reg = &mcu->vcd[i];
		reg_val = *mcu->ioregs[reg->i].addr;
		if (mcu->vcd[i].reg_lowi >= 0) {
			rh = *mcu->ioregs[reg->i].addr;
			rl = *mcu->ioregs[reg->reg_lowi].addr;
			reg_val = ((uint16_t)(rh<<8)&0xFF00U)|
			          (uint16_t)(rl&0x00FFU);
		}

		/* Has it been changed? */
		if (reg_val == reg->old_val) {
			continue;
		} else {
			reg->old_val = reg_val;
		}
	}
}

static void print_reg16(char *buf, uint32_t len, uint8_t hr, uint8_t lr)
{
	uint32_t i;
	uint32_t j = 0;
	uint32_t reg;
	size_t rbits;

	j = 0;
	rbits = 16;
	reg = ((uint16_t)(hr<<8)&0xFF00U)|(uint16_t)(lr&0x00FFU);

	if (len < (rbits+1)) {
		buf[0] = 0;
		return;
	}
	for (i = 0; i < rbits; i++) {
		if ((reg >> (rbits-1-i)) & 1) {
			buf[j++] = '1';
		} else {
			buf[j++] = '0';
		}
	}
	buf[j] = 0;
}

static void print_reg(char *buf, unsigned int len, unsigned char r)
{
	uint32_t i;
	uint32_t j;
	size_t rbits;

	j = 0;
	rbits = 8;

	if (len < (rbits+1)) {
		buf[0] = 0;
		return;
	}
	for (i = 0; i < rbits; i++) {
		if ((r >> (rbits-1-i)) & 1) {
			buf[j++] = '1';
		} else {
			buf[j++] = '0';
		}
	}
	buf[j] = 0;
}

static void print_regbit(char *buf, unsigned int len, unsigned char r,
                         short bit)
{
	if (len < 2) {
		buf[0] = 0;
		return;
	}
	buf[0] = ((r >> bit) & 1) ? '1' : '0';
	buf[1] = 0;
}
